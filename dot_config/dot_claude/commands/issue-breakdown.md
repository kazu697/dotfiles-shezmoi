---
description: Analyze GitHub issue, organize requirements through Q&A, and create sub-issues
allowed-tools: Bash, Read, Glob, Grep, AskUserQuestion, TodoWrite, Task
---

# /issue-breakdown - Issue Analysis and Sub-Issue Creation

Analyze a GitHub issue, clarify requirements through interactive Q&A, update the parent issue with organized requirements, and create sub-issues for each task.

## Arguments

- `$ARGUMENTS`: Issue number, URL, or user filter (e.g., `123`, `https://github.com/snkrdunk/snkrdunk.com/issues/123`, `--assignee @me`)

## Process

### Phase 1: Issue Fetching

1. **Determine input type and fetch issue(s)**:

   ```bash
   # If argument is a number or URL
   gh issue view <number_or_url> --json number,title,body,labels,assignees,milestone,url

   # If argument is a user filter or empty (default to @me)
   gh issue list --assignee @me --json number,title,labels,assignees --limit 20
   ```

2. **If multiple issues found**: Present list and ask user to select one issue to analyze

3. **Display the selected issue content** for review

### Phase 2: Requirements Analysis

1. **Parse the issue body** to identify:
   - Background/Context
   - Problem statement
   - Proposed solution (if any)
   - Acceptance criteria
   - Technical constraints
   - Dependencies

2. **Ask clarifying questions** using AskUserQuestion tool:
   - What is the primary goal? (if unclear)
   - What are the acceptance criteria? (if not defined)
   - Are there any technical constraints?
   - What is the priority of each requirement?
   - Are there any dependencies on other issues/features?

3. **Confirm understanding** with user before proceeding

### Phase 3: Task Breakdown

1. **Analyze requirements** and break down into actionable tasks:
   - Each task should be independently implementable
   - Tasks should follow SNKRDUNK v2 architecture patterns
   - Consider: API changes, database migrations, business logic, tests, documentation

2. **Categorize tasks** by type:
   - `design`: Architecture/design decisions
   - `backend`: Server-side implementation
   - `frontend`: Client-side implementation
   - `database`: Schema changes/migrations
   - `test`: Test implementation
   - `docs`: Documentation updates

3. **Estimate complexity** for each task (based on repository's size labels):
   - XS: ~1 day to In Review
   - S: ~3 days to In Review
   - M: ~5 days to In Review
   - L: ~7 days to In Review
   - XL: 10+ days to In Review (should be further broken down)

4. **Present task breakdown** to user for review and approval

### Phase 4: Update Parent Issue

1. **Generate structured requirements summary** in the following format:

   ```markdown
   ## Requirements Summary (Auto-generated by Claude Code)

   ### Background
   [Summarized context and problem statement]

   ### Goals
   - [ ] Goal 1
   - [ ] Goal 2

   ### Acceptance Criteria
   - [ ] AC1: Description
   - [ ] AC2: Description

   ### Technical Approach
   [Brief description of implementation approach]

   ### Task Breakdown
   | # | Task | Type | Size | Sub-Issue |
   |---|------|------|------|-----------|
   | 1 | Task description | backend | M | #xxx |
   | 2 | Task description | frontend | S | #xxx |

   ### Dependencies
   - Depends on: #issue_number (if any)
   - Blocks: #issue_number (if any)
   ```

2. **Update the parent issue body** with the requirements summary:
   ```bash
   gh issue edit <number> --body "$UPDATED_BODY"
   ```

### Phase 5: Create Sub-Issues

1. **For each approved task**, create a sub-issue:

   ```bash
   gh issue create \
     --title "[Sub] Task title" \
     --body "Parent Issue: #<parent_number>

     ## Task Description
     [Detailed task description]

     ## Acceptance Criteria
     - [ ] Criteria 1
     - [ ] Criteria 2

     ## Technical Notes
     [Implementation hints, file locations, patterns to follow]

     ## Related Files
     - path/to/relevant/file.go

     ---
     *This sub-issue was created by Claude Code /issue-breakdown command*" \
     --label "size:<size>,claude-code"
   ```

2. **Link sub-issues** to parent by updating the parent issue's task table with issue numbers

3. **Add labels** based on task type and size:
   - Size labels (use existing): `size:XS`, `size:S`, `size:M`, `size:L`, `size:XL`
   - Always add: `claude-code`
   - Domain labels (if applicable): `engineer`, `platform`, `security`, `user`, etc.

### Phase 6: Summary

1. **Display summary** of created artifacts:
   - Parent issue URL with updated requirements
   - List of created sub-issues with URLs
   - Recommended implementation order

2. **Suggest next steps**:
   - Which sub-issue to start with
   - Any blocking dependencies to resolve first

## Example Usage

```bash
# Analyze specific issue
/issue-breakdown 123

# Analyze issue from URL
/issue-breakdown https://github.com/snkrdunk/snkrdunk.com/issues/123

# List and select from issues assigned to me
/issue-breakdown --assignee @me

# List and select from issues with specific label
/issue-breakdown --label enhancement
```

## Output Format

After completion, display:

```
‚úÖ Issue Breakdown Complete

üìã Parent Issue: #123 - [Title]
   URL: https://github.com/snkrdunk/snkrdunk.com/issues/123
   Status: Updated with requirements summary

üìù Created Sub-Issues:
   1. #124 - [Sub] Design API structure (size:M, design)
   2. #125 - [Sub] Implement database migration (size:XS, database)
   3. #126 - [Sub] Create v2 command usecase (size:S, backend)
   4. #127 - [Sub] Add unit tests (size:S, test)
   5. #128 - [Sub] Update API documentation (size:XS, docs)

üîÑ Recommended Order:
   1. #124 (Design) ‚Üí 2. #125 (Database) ‚Üí 3. #126 (Backend) ‚Üí 4. #127 (Test) ‚Üí 5. #128 (Docs)

üí° Next Step: Start with #124 to finalize the design before implementation.
```

## Important Notes

- Always ask for user confirmation before modifying issues
- Preserve existing issue content when updating
- Follow SNKRDUNK's v2 CQRS patterns for backend task breakdown
- Use appropriate labels from the repository
- Link parent and child issues bidirectionally
